# api-gateway/deployment.yaml
# --- Deployment para API Gateway ---
apiVersion: apps/v1
kind: Deployment
metadata:
  # Nombre del Deployment
  name: api-gateway-deployment
  # Namespace donde se desplegará (¡ASEGÚRATE QUE EXISTA!)
  namespace: nyro-develop
  labels:
    app: api-gateway
spec:
  # Número de réplicas (considera 2+ para alta disponibilidad)
  replicas: 1
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
    spec:
      containers:
        - name: api-gateway
          # La imagen será actualizada por el pipeline CI/CD
          # Ejemplo de imagen inicial, el pipeline la reemplazará
    image: ghcr.io/dev-nyro/api-gateway:develop-d58695f
          # Política de pull de imagen (Always para asegurar la última, IfNotPresent si prefieres caché)
          imagePullPolicy: Always
          ports:
            # Nombre del puerto para referencia interna (ej. en Service, Probes)
            - name: http
              # Puerto que expone tu aplicación DENTRO del contenedor (Dockerfile/Gunicorn)
              containerPort: 8080
              protocol: TCP
          # No se necesita command/args si el CMD/ENTRYPOINT del Dockerfile es correcto y usa el puerto 8080
          # env: # La variable PORT ya debería estar configurada en tu app o Dockerfile si es necesaria
          #   - name: PORT
          #     value: "8080"
          # Carga variables de entorno desde ConfigMaps y Secrets
          envFrom:
            - configMapRef:
                # ¡IMPORTANTE! Este ConfigMap DEBE existir en el namespace 'nyro-develop'
                name: api-gateway-config
            - secretRef:
                # ¡IMPORTANTE! Este Secret DEBE existir en el namespace 'nyro-develop'
                name: api-gateway-secrets
          # Límites y solicitudes de recursos (ajustar según monitorización)
          resources:
            requests: # Mínimo garantizado
              cpu: "100m" # 10% de un vCPU
              memory: "128Mi" # 128 Mebibytes
            limits: # Máximo permitido
              cpu: "500m" # 50% de un vCPU
              memory: "512Mi" # 512 Mebibytes
          # Sonda de Readiness: ¿Está listo el pod para recibir tráfico?
          readinessProbe:
            httpGet:
              # Path del endpoint de health check en tu API Gateway (¡ASEGÚRATE QUE EXISTA Y FUNCIONE!)
              path: /health
              # Referencia al nombre del puerto definido arriba
              port: http
            # Espera inicial antes del primer chequeo
            initialDelaySeconds: 15
            # Frecuencia del chequeo
            periodSeconds: 10
            # Tiempo máximo para esperar respuesta
            timeoutSeconds: 5
            # Umbral de fallos para marcar como No Listo
            failureThreshold: 3
            # Umbral de éxitos para marcar como Listo
            successThreshold: 1
          # Sonda de Liveness: ¿Está vivo el pod o necesita reiniciarse?
          livenessProbe:
            httpGet:
              # Usualmente el mismo endpoint que readiness
              path: /health
              port: http
            # Espera inicial más larga antes de considerar reiniciar
            initialDelaySeconds: 30
            periodSeconds: 15
            timeoutSeconds: 5
            failureThreshold: 3
            successThreshold: 1
      # imagePullSecrets: # Descomentar si GHCR es privado y necesitas un secreto para autenticar
      # - name: ghcr-secret # Nombre del secreto tipo 'kubernetes.io/dockerconfigjson'